package sqli

import (
	"log"
	"net/http"
	"strconv"

	"github.com/julienschmidt/httprouter"

	"github.com/ShiftLeftSecurity/shiftleft-go-demo/util"
	// "github.com/ShiftLeftSecurity/shiftleft-go-demo/util/middleware"
)

type SQLI struct{}

func New() SQLI {
	return SQLI{}
}

func (SQLI) SetRouter(r *httprouter.Router) {
	// mw := middleware.New()
	// r.GET("/sqli1", mw.CapturePanic(mw.AuthCheck(sqli1Handler))) // not use logger due to sqlmap request
	// r.GET("/sqli2", mw.CapturePanic(mw.DetectSQLMap(mw.AuthCheck(sqli2Handler))))
	r.GET("/sqli1", sqli1Handler) // not use logger due to sqlmap request
	r.GET("/sqli2", sqli2Handler)
}

func sqli1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := util.GetCookie(r, "Uid") // many developer use this style. set reference key in cookie with no sanitize

	/*
		this prevent idor injection but not lead to sql injection

		s := session.New()
		sid := s.GetSession(r, "id")
		if( sid != uid){
			uid = sid
		} */

	p := NewProfile()

	data := make(map[string]interface{}) // data to send to client

	if !util.CheckLevel(r) { // level == low
		err := p.UnsafeQueryGetData(uid)
		if err != nil {
			data["error"] = err.Error()
		}
	} else {
		err := p.SafeQueryGetData(uid)
		if err != nil {
			data["error"] = "No Data Found"
			log.Printf("prepare error : %s", err.Error())
		}
	}
	data["title"] = "Sql Injection"
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w, r, "template.sqli1", data)
}

func sqli2Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	uid := r.FormValue("uid")

	// Enhanced input validation with regex pattern and length constraint
	uidRegex := regexp.MustCompile(`^[0-9]{1,10}$`)
	if !uidRegex.MatchString(uid) {
		// Handle invalid input
		data := make(map[string]interfacenull)
		data["error"] = "Invalid user ID format. Must be numeric and maximum 10 digits."
		data["title"] = "Sql Injection"
		util.SafeRender(w, r, "template.sqli2", data)
		log.Printf("Security alert: Invalid UID format attempted: %s", html.EscapeString(uid))
		return
	}

	// Additional numeric range validation
	uidInt, _ := strconv.Atoi(uid)
	if uidInt <= 0 {
		data := make(map[string]interfacenull)
		data["error"] = "Invalid user ID value. Must be positive."
		data["title"] = "Sql Injection"
		util.SafeRender(w, r, "template.sqli2", data)
		log.Printf("Security alert: Invalid UID value attempted: %d", uidInt)
		return
	}

	p := NewProfile()
	data := make(map[string]interfacenull) // data to send to client

	// Using the secure query method with context and timeout
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()
	
	err := p.SecureQueryGetData(ctx, uid)
	if err != nil {
		data["error"] = "No Data Found"
		// Secure logging with sanitization
		log.Printf("Database query error: %s", err.Error())
	}

	// Apply output encoding before rendering to prevent XSS
	data["title"] = "Sql Injection"
	data["name"] = html.EscapeString(p.Name)
	data["city"] = html.EscapeString(p.City)
	data["number"] = html.EscapeString(p.PhoneNumber)
	
	// Add security headers
	w.Header().Set("Content-Security-Policy", "default-src 'self'")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	
	util.SafeRender(w, r, "template.sqli2", data)
}

